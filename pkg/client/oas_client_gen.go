// Code generated by ogen, DO NOT EDIT.

package client

import (
	"context"
	"net/url"
	"strings"

	"github.com/go-faster/errors"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
)

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// DELETEV1AuthSignout invokes DELETE_/v1/auth/signout operation.
	//
	// #### Controller:
	// `github.com/ubccr/grendel/internal/api.(*Handler).AuthSignout`
	// #### Middlewares:
	// - `github.com/go-fuego/fuego.defaultLogger.middleware`
	// ---
	// Signout user.
	//
	// DELETE /v1/auth/signout
	DELETEV1AuthSignout(ctx context.Context, params DELETEV1AuthSignoutParams) (*GenericResponse, error)
	// DELETEV1BmcJobsJids invokes DELETE_/v1/bmc/jobs/:jids operation.
	//
	// #### Controller:
	// `github.com/ubccr/grendel/internal/api.(*Handler).BmcJobDelete`
	// #### Middlewares:
	// - `github.com/go-fuego/fuego.defaultLogger.middleware`
	// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
	// ---
	// Delete redfish jobs from node(s) by JID.
	//
	// DELETE /v1/bmc/jobs/{jids}
	DELETEV1BmcJobsJids(ctx context.Context, params DELETEV1BmcJobsJidsParams) ([]JobMessage, error)
	// DELETEV1BmcSel invokes DELETE_/v1/bmc/sel operation.
	//
	// #### Controller:
	// `github.com/ubccr/grendel/internal/api.(*Handler).BmcSelClear`
	// #### Middlewares:
	// - `github.com/go-fuego/fuego.defaultLogger.middleware`
	// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
	// ---
	// Clear system event log on node(s).
	//
	// DELETE /v1/bmc/sel
	DELETEV1BmcSel(ctx context.Context, params DELETEV1BmcSelParams) ([]JobMessage, error)
	// DELETEV1Images invokes DELETE_/v1/images operation.
	//
	// #### Controller:
	// `github.com/ubccr/grendel/internal/api.(*Handler).BootImageDelete`
	// #### Middlewares:
	// - `github.com/go-fuego/fuego.defaultLogger.middleware`
	// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
	// ---
	// Delete images by name.
	//
	// DELETE /v1/images
	DELETEV1Images(ctx context.Context, params DELETEV1ImagesParams) (*GenericResponse, error)
	// DELETEV1Nodes invokes DELETE_/v1/nodes operation.
	//
	// #### Controller:
	// `github.com/ubccr/grendel/internal/api.(*Handler).NodeDelete`
	// #### Middlewares:
	// - `github.com/go-fuego/fuego.defaultLogger.middleware`
	// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
	// ---
	// Delete nodes by nodeset and/or tags.
	//
	// DELETE /v1/nodes
	DELETEV1Nodes(ctx context.Context, params DELETEV1NodesParams) (*GenericResponse, error)
	// DELETEV1RolesNames invokes DELETE_/v1/roles/:names operation.
	//
	// #### Controller:
	// `github.com/ubccr/grendel/internal/api.(*Handler).DeleteRoles`
	// #### Middlewares:
	// - `github.com/go-fuego/fuego.defaultLogger.middleware`
	// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
	// ---
	// Delete roles.
	//
	// DELETE /v1/roles/{names}
	DELETEV1RolesNames(ctx context.Context, params DELETEV1RolesNamesParams) (*GenericResponse, error)
	// DELETEV1UsersUsernames invokes DELETE_/v1/users/:usernames operation.
	//
	// #### Controller:
	// `github.com/ubccr/grendel/internal/api.(*Handler).UserDelete`
	// #### Middlewares:
	// - `github.com/go-fuego/fuego.defaultLogger.middleware`
	// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
	// ---
	// Delete users.
	//
	// DELETE /v1/users/{usernames}
	DELETEV1UsersUsernames(ctx context.Context, params DELETEV1UsersUsernamesParams) (*GenericResponse, error)
	// GETV1Bmc invokes GET_/v1/bmc operation.
	//
	// #### Controller:
	// `github.com/ubccr/grendel/internal/api.(*Handler).BmcQuery`
	// #### Middlewares:
	// - `github.com/go-fuego/fuego.defaultLogger.middleware`
	// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
	// ---
	// Get redfish info from node(s).
	//
	// GET /v1/bmc
	GETV1Bmc(ctx context.Context, params GETV1BmcParams) ([]RedfishSystem, error)
	// GETV1BmcJobs invokes GET_/v1/bmc/jobs operation.
	//
	// #### Controller:
	// `github.com/ubccr/grendel/internal/api.(*Handler).BmcJobList`
	// #### Middlewares:
	// - `github.com/go-fuego/fuego.defaultLogger.middleware`
	// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
	// ---
	// Get redfish jobs from node(s).
	//
	// GET /v1/bmc/jobs
	GETV1BmcJobs(ctx context.Context, params GETV1BmcJobsParams) ([]RedfishJob, error)
	// GETV1BmcMetrics invokes GET_/v1/bmc/metrics operation.
	//
	// #### Controller:
	// `github.com/ubccr/grendel/internal/api.(*Handler).BmcMetricReports`
	// #### Middlewares:
	// - `github.com/go-fuego/fuego.defaultLogger.middleware`
	// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
	// ---
	// Get metric reports by nodeset.
	//
	// GET /v1/bmc/metrics
	GETV1BmcMetrics(ctx context.Context, params GETV1BmcMetricsParams) ([]RedfishMetricReport, error)
	// GETV1DbDump invokes GET_/v1/db/dump operation.
	//
	// #### Controller:
	// `github.com/ubccr/grendel/internal/api.(*Handler).Dump`
	// #### Middlewares:
	// - `github.com/go-fuego/fuego.defaultLogger.middleware`
	// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
	// ---
	// Get a backup of the DB.
	//
	// GET /v1/db/dump
	GETV1DbDump(ctx context.Context, params GETV1DbDumpParams) (*DataDump, error)
	// GETV1GrendelEvents invokes GET_/v1/grendel/events operation.
	//
	// #### Controller:
	// `github.com/ubccr/grendel/internal/api.(*Handler).GetEvents`
	// #### Middlewares:
	// - `github.com/go-fuego/fuego.defaultLogger.middleware`
	// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
	// ---.
	//
	// GET /v1/grendel/events
	GETV1GrendelEvents(ctx context.Context, params GETV1GrendelEventsParams) ([]Event, error)
	// GETV1Images invokes GET_/v1/images operation.
	//
	// #### Controller:
	// `github.com/ubccr/grendel/internal/api.(*Handler).BootImageList`
	// #### Middlewares:
	// - `github.com/go-fuego/fuego.defaultLogger.middleware`
	// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
	// ---
	// List all images.
	//
	// GET /v1/images
	GETV1Images(ctx context.Context, params GETV1ImagesParams) ([]BootImage, error)
	// GETV1ImagesFind invokes GET_/v1/images/find operation.
	//
	// #### Controller:
	// `github.com/ubccr/grendel/internal/api.(*Handler).BootImageFind`
	// #### Middlewares:
	// - `github.com/go-fuego/fuego.defaultLogger.middleware`
	// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
	// ---
	// Find images by name.
	//
	// GET /v1/images/find
	GETV1ImagesFind(ctx context.Context, params GETV1ImagesFindParams) ([]BootImage, error)
	// GETV1Nodes invokes GET_/v1/nodes operation.
	//
	// #### Controller:
	// `github.com/ubccr/grendel/internal/api.(*Handler).NodeList`
	// #### Middlewares:
	// - `github.com/go-fuego/fuego.defaultLogger.middleware`
	// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
	// ---
	// List all nodes.
	//
	// GET /v1/nodes
	GETV1Nodes(ctx context.Context, params GETV1NodesParams) ([]Host, error)
	// GETV1NodesFind invokes GET_/v1/nodes/find operation.
	//
	// #### Controller:
	// `github.com/ubccr/grendel/internal/api.(*Handler).NodeFind`
	// #### Middlewares:
	// - `github.com/go-fuego/fuego.defaultLogger.middleware`
	// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
	// ---
	// Find nodes by nodeset and/or tags.
	//
	// GET /v1/nodes/find
	GETV1NodesFind(ctx context.Context, params GETV1NodesFindParams) ([]Host, error)
	// GETV1NodesTokenInterface invokes GET_/v1/nodes/token/:interface operation.
	//
	// #### Controller:
	// `github.com/ubccr/grendel/internal/api.(*Handler).NodeBootToken`
	// #### Middlewares:
	// - `github.com/go-fuego/fuego.defaultLogger.middleware`
	// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
	// ---
	// Create a boot token for the provision server. Used for debugging requests made by images.
	//
	// GET /v1/nodes/token/{interface}
	GETV1NodesTokenInterface(ctx context.Context, params GETV1NodesTokenInterfaceParams) (*NodeBootTokenResponse, error)
	// GETV1Roles invokes GET_/v1/roles operation.
	//
	// #### Controller:
	// `github.com/ubccr/grendel/internal/api.(*Handler).GetRoles`
	// #### Middlewares:
	// - `github.com/go-fuego/fuego.defaultLogger.middleware`
	// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
	// ---
	// Get roles and permissions.
	//
	// GET /v1/roles
	GETV1Roles(ctx context.Context, params GETV1RolesParams) (*GetRolesResponse, error)
	// GETV1SwitchNodesetLldp invokes GET_/v1/switch/:nodeset/lldp operation.
	//
	// #### Controller:
	// `github.com/ubccr/grendel/internal/api.(*Handler).SwitchGetLLDP`
	// #### Middlewares:
	// - `github.com/go-fuego/fuego.defaultLogger.middleware`
	// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
	// ---
	// Get switch LLDP info.
	//
	// GET /v1/switch/{nodeset}/lldp
	GETV1SwitchNodesetLldp(ctx context.Context, params GETV1SwitchNodesetLldpParams) ([]LLDP, error)
	// GETV1Users invokes GET_/v1/users operation.
	//
	// #### Controller:
	// `github.com/ubccr/grendel/internal/api.(*Handler).UserList`
	// #### Middlewares:
	// - `github.com/go-fuego/fuego.defaultLogger.middleware`
	// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
	// ---
	// List all users.
	//
	// GET /v1/users
	GETV1Users(ctx context.Context, params GETV1UsersParams) ([]User, error)
	// PATCHV1AuthReset invokes PATCH_/v1/auth/reset operation.
	//
	// #### Controller:
	// `github.com/ubccr/grendel/internal/api.(*Handler).AuthReset`
	// #### Middlewares:
	// - `github.com/go-fuego/fuego.defaultLogger.middleware`
	// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
	// ---
	// Change password.
	//
	// PATCH /v1/auth/reset
	PATCHV1AuthReset(ctx context.Context, request *AuthResetRequest, params PATCHV1AuthResetParams) (*GenericResponse, error)
	// PATCHV1NodesImage invokes PATCH_/v1/nodes/image operation.
	//
	// #### Controller:
	// `github.com/ubccr/grendel/internal/api.(*Handler).NodeBootImage`
	// #### Middlewares:
	// - `github.com/go-fuego/fuego.defaultLogger.middleware`
	// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
	// ---
	// Update nodes boot image by nodeset and/or tags.
	//
	// PATCH /v1/nodes/image
	PATCHV1NodesImage(ctx context.Context, request *NodeBootImageRequest, params PATCHV1NodesImageParams) (*GenericResponse, error)
	// PATCHV1NodesProvision invokes PATCH_/v1/nodes/provision operation.
	//
	// #### Controller:
	// `github.com/ubccr/grendel/internal/api.(*Handler).NodeProvision`
	// #### Middlewares:
	// - `github.com/go-fuego/fuego.defaultLogger.middleware`
	// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
	// ---
	// Provision / Unprovision nodes by nodeset and/or tags.
	//
	// PATCH /v1/nodes/provision
	PATCHV1NodesProvision(ctx context.Context, request *NodeProvisionRequest, params PATCHV1NodesProvisionParams) (*GenericResponse, error)
	// PATCHV1NodesTagsAction invokes PATCH_/v1/nodes/tags/:action operation.
	//
	// #### Controller:
	// `github.com/ubccr/grendel/internal/api.(*Handler).NodeTags`
	// #### Middlewares:
	// - `github.com/go-fuego/fuego.defaultLogger.middleware`
	// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
	// ---
	// Update nodes tags by nodeset and/or tags.
	//
	// PATCH /v1/nodes/tags/{action}
	PATCHV1NodesTagsAction(ctx context.Context, request *NodeTagsRequest, params PATCHV1NodesTagsActionParams) (*GenericResponse, error)
	// PATCHV1Roles invokes PATCH_/v1/roles operation.
	//
	// #### Controller:
	// `github.com/ubccr/grendel/internal/api.(*Handler).PatchRoles`
	// #### Middlewares:
	// - `github.com/go-fuego/fuego.defaultLogger.middleware`
	// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
	// ---
	// Edit role permissions.
	//
	// PATCH /v1/roles
	PATCHV1Roles(ctx context.Context, request *PatchRolesRequest, params PATCHV1RolesParams) (*GenericResponse, error)
	// PATCHV1UsersUsernamesEnable invokes PATCH_/v1/users/:usernames/enable operation.
	//
	// #### Controller:
	// `github.com/ubccr/grendel/internal/api.(*Handler).UserEnable`
	// #### Middlewares:
	// - `github.com/go-fuego/fuego.defaultLogger.middleware`
	// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
	// ---
	// Update users enable.
	//
	// PATCH /v1/users/{usernames}/enable
	PATCHV1UsersUsernamesEnable(ctx context.Context, request *UserEnableRequest, params PATCHV1UsersUsernamesEnableParams) (*GenericResponse, error)
	// PATCHV1UsersUsernamesRole invokes PATCH_/v1/users/:usernames/role operation.
	//
	// #### Controller:
	// `github.com/ubccr/grendel/internal/api.(*Handler).UserRole`
	// #### Middlewares:
	// - `github.com/go-fuego/fuego.defaultLogger.middleware`
	// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
	// ---
	// Update users role.
	//
	// PATCH /v1/users/{usernames}/role
	PATCHV1UsersUsernamesRole(ctx context.Context, request *UserRoleRequest, params PATCHV1UsersUsernamesRoleParams) (*GenericResponse, error)
	// POSTV1AuthSignin invokes POST_/v1/auth/signin operation.
	//
	// #### Controller:
	// `github.com/ubccr/grendel/internal/api.(*Handler).AuthSignin`
	// #### Middlewares:
	// - `github.com/go-fuego/fuego.defaultLogger.middleware`
	// ---
	// signin user.
	//
	// POST /v1/auth/signin
	POSTV1AuthSignin(ctx context.Context, request *AuthRequest, params POSTV1AuthSigninParams) (*AuthResponse, error)
	// POSTV1AuthSignup invokes POST_/v1/auth/signup operation.
	//
	// #### Controller:
	// `github.com/ubccr/grendel/internal/api.(*Handler).AuthSignup`
	// #### Middlewares:
	// - `github.com/go-fuego/fuego.defaultLogger.middleware`
	// ---
	// Signup user.
	//
	// POST /v1/auth/signup
	POSTV1AuthSignup(ctx context.Context, request *AuthSignupRequest, params POSTV1AuthSignupParams) (*AuthResponse, error)
	// POSTV1AuthToken invokes POST_/v1/auth/token operation.
	//
	// #### Controller:
	// `github.com/ubccr/grendel/internal/api.(*Handler).AuthToken`
	// #### Middlewares:
	// - `github.com/go-fuego/fuego.defaultLogger.middleware`
	// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
	// ---
	// Create API token.
	//
	// POST /v1/auth/token
	POSTV1AuthToken(ctx context.Context, request *AuthTokenRequest, params POSTV1AuthTokenParams) (*AuthTokenReponse, error)
	// POSTV1BmcConfigureAuto invokes POST_/v1/bmc/configure/auto operation.
	//
	// #### Controller:
	// `github.com/ubccr/grendel/internal/api.(*Handler).BmcAutoConfigure`
	// #### Middlewares:
	// - `github.com/go-fuego/fuego.defaultLogger.middleware`
	// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
	// ---
	// Set BMC to autoconfigure.
	//
	// POST /v1/bmc/configure/auto
	POSTV1BmcConfigureAuto(ctx context.Context, params POSTV1BmcConfigureAutoParams) ([]JobMessage, error)
	// POSTV1BmcConfigureImport invokes POST_/v1/bmc/configure/import operation.
	//
	// #### Controller:
	// `github.com/ubccr/grendel/internal/api.(*Handler).BmcImportConfiguration`
	// #### Middlewares:
	// - `github.com/go-fuego/fuego.defaultLogger.middleware`
	// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
	// ---
	// Manually import system configuration to BMC.
	//
	// POST /v1/bmc/configure/import
	POSTV1BmcConfigureImport(ctx context.Context, request *BmcImportConfigurationRequest, params POSTV1BmcConfigureImportParams) ([]JobMessage, error)
	// POSTV1BmcPowerBmc invokes POST_/v1/bmc/power/bmc operation.
	//
	// #### Controller:
	// `github.com/ubccr/grendel/internal/api.(*Handler).BmcPower`
	// #### Middlewares:
	// - `github.com/go-fuego/fuego.defaultLogger.middleware`
	// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
	// ---
	// Reboot node(s) BMC.
	//
	// POST /v1/bmc/power/bmc
	POSTV1BmcPowerBmc(ctx context.Context, params POSTV1BmcPowerBmcParams) ([]JobMessage, error)
	// POSTV1BmcPowerOs invokes POST_/v1/bmc/power/os operation.
	//
	// #### Controller:
	// `github.com/ubccr/grendel/internal/api.(*Handler).BmcOsPower`
	// #### Middlewares:
	// - `github.com/go-fuego/fuego.defaultLogger.middleware`
	// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
	// ---
	// Change power status of node(s).
	//
	// POST /v1/bmc/power/os
	POSTV1BmcPowerOs(ctx context.Context, request *BmcOsPowerBody, params POSTV1BmcPowerOsParams) ([]JobMessage, error)
	// POSTV1DbRestore invokes POST_/v1/db/restore operation.
	//
	// #### Controller:
	// `github.com/ubccr/grendel/internal/api.(*Handler).Restore`
	// #### Middlewares:
	// - `github.com/go-fuego/fuego.defaultLogger.middleware`
	// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
	// ---
	// Restore a backup of the DB.
	//
	// POST /v1/db/restore
	POSTV1DbRestore(ctx context.Context, request *DataDump, params POSTV1DbRestoreParams) (*GenericResponse, error)
	// POSTV1Images invokes POST_/v1/images operation.
	//
	// #### Controller:
	// `github.com/ubccr/grendel/internal/api.(*Handler).BootImageAdd`
	// #### Middlewares:
	// - `github.com/go-fuego/fuego.defaultLogger.middleware`
	// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
	// ---
	// Add images.
	//
	// POST /v1/images
	POSTV1Images(ctx context.Context, request *BootImageAddRequest, params POSTV1ImagesParams) (*GenericResponse, error)
	// POSTV1Nodes invokes POST_/v1/nodes operation.
	//
	// #### Controller:
	// `github.com/ubccr/grendel/internal/api.(*Handler).NodeAdd`
	// #### Middlewares:
	// - `github.com/go-fuego/fuego.defaultLogger.middleware`
	// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
	// ---
	// Add nodes.
	//
	// POST /v1/nodes
	POSTV1Nodes(ctx context.Context, request *NodeAddRequest, params POSTV1NodesParams) (*GenericResponse, error)
	// POSTV1Roles invokes POST_/v1/roles operation.
	//
	// #### Controller:
	// `github.com/ubccr/grendel/internal/api.(*Handler).PostRoles`
	// #### Middlewares:
	// - `github.com/go-fuego/fuego.defaultLogger.middleware`
	// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
	// ---
	// Add roles.
	//
	// POST /v1/roles
	POSTV1Roles(ctx context.Context, request *PostRolesRequest, params POSTV1RolesParams) (*GenericResponse, error)
	// POSTV1Users invokes POST_/v1/users operation.
	//
	// #### Controller:
	// `github.com/ubccr/grendel/internal/api.(*Handler).UserStore`
	// #### Middlewares:
	// - `github.com/go-fuego/fuego.defaultLogger.middleware`
	// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
	// ---
	// Add new user.
	//
	// POST /v1/users
	POSTV1Users(ctx context.Context, request *UserStoreRequest, params POSTV1UsersParams) (*UserStoreResponse, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec       SecuritySource
	baseClient
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		sec:        sec,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// DELETEV1AuthSignout invokes DELETE_/v1/auth/signout operation.
//
// #### Controller:
// `github.com/ubccr/grendel/internal/api.(*Handler).AuthSignout`
// #### Middlewares:
// - `github.com/go-fuego/fuego.defaultLogger.middleware`
// ---
// Signout user.
//
// DELETE /v1/auth/signout
func (c *Client) DELETEV1AuthSignout(ctx context.Context, params DELETEV1AuthSignoutParams) (*GenericResponse, error) {
	res, err := c.sendDELETEV1AuthSignout(ctx, params)
	return res, err
}

func (c *Client) sendDELETEV1AuthSignout(ctx context.Context, params DELETEV1AuthSignoutParams) (res *GenericResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/auth/signout"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Accept",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Accept.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityHeaderAuth(ctx, DELETEV1AuthSignoutOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HeaderAuth\"")
			}
		}
		{

			switch err := c.securityCookieAuth(ctx, DELETEV1AuthSignoutOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDELETEV1AuthSignoutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DELETEV1BmcJobsJids invokes DELETE_/v1/bmc/jobs/:jids operation.
//
// #### Controller:
// `github.com/ubccr/grendel/internal/api.(*Handler).BmcJobDelete`
// #### Middlewares:
// - `github.com/go-fuego/fuego.defaultLogger.middleware`
// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
// ---
// Delete redfish jobs from node(s) by JID.
//
// DELETE /v1/bmc/jobs/{jids}
func (c *Client) DELETEV1BmcJobsJids(ctx context.Context, params DELETEV1BmcJobsJidsParams) ([]JobMessage, error) {
	res, err := c.sendDELETEV1BmcJobsJids(ctx, params)
	return res, err
}

func (c *Client) sendDELETEV1BmcJobsJids(ctx context.Context, params DELETEV1BmcJobsJidsParams) (res []JobMessage, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/bmc/jobs/"
	{
		// Encode "jids" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "jids",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Jids))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "nodeset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "nodeset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Nodeset.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "tags" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "tags",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Tags.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Accept",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Accept.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityHeaderAuth(ctx, DELETEV1BmcJobsJidsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HeaderAuth\"")
			}
		}
		{

			switch err := c.securityCookieAuth(ctx, DELETEV1BmcJobsJidsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDELETEV1BmcJobsJidsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DELETEV1BmcSel invokes DELETE_/v1/bmc/sel operation.
//
// #### Controller:
// `github.com/ubccr/grendel/internal/api.(*Handler).BmcSelClear`
// #### Middlewares:
// - `github.com/go-fuego/fuego.defaultLogger.middleware`
// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
// ---
// Clear system event log on node(s).
//
// DELETE /v1/bmc/sel
func (c *Client) DELETEV1BmcSel(ctx context.Context, params DELETEV1BmcSelParams) ([]JobMessage, error) {
	res, err := c.sendDELETEV1BmcSel(ctx, params)
	return res, err
}

func (c *Client) sendDELETEV1BmcSel(ctx context.Context, params DELETEV1BmcSelParams) (res []JobMessage, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/bmc/sel"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "nodeset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "nodeset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Nodeset.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "tags" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "tags",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Tags.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Accept",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Accept.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityHeaderAuth(ctx, DELETEV1BmcSelOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HeaderAuth\"")
			}
		}
		{

			switch err := c.securityCookieAuth(ctx, DELETEV1BmcSelOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDELETEV1BmcSelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DELETEV1Images invokes DELETE_/v1/images operation.
//
// #### Controller:
// `github.com/ubccr/grendel/internal/api.(*Handler).BootImageDelete`
// #### Middlewares:
// - `github.com/go-fuego/fuego.defaultLogger.middleware`
// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
// ---
// Delete images by name.
//
// DELETE /v1/images
func (c *Client) DELETEV1Images(ctx context.Context, params DELETEV1ImagesParams) (*GenericResponse, error) {
	res, err := c.sendDELETEV1Images(ctx, params)
	return res, err
}

func (c *Client) sendDELETEV1Images(ctx context.Context, params DELETEV1ImagesParams) (res *GenericResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/images"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "names" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "names",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Names.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Accept",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Accept.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityHeaderAuth(ctx, DELETEV1ImagesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HeaderAuth\"")
			}
		}
		{

			switch err := c.securityCookieAuth(ctx, DELETEV1ImagesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDELETEV1ImagesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DELETEV1Nodes invokes DELETE_/v1/nodes operation.
//
// #### Controller:
// `github.com/ubccr/grendel/internal/api.(*Handler).NodeDelete`
// #### Middlewares:
// - `github.com/go-fuego/fuego.defaultLogger.middleware`
// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
// ---
// Delete nodes by nodeset and/or tags.
//
// DELETE /v1/nodes
func (c *Client) DELETEV1Nodes(ctx context.Context, params DELETEV1NodesParams) (*GenericResponse, error) {
	res, err := c.sendDELETEV1Nodes(ctx, params)
	return res, err
}

func (c *Client) sendDELETEV1Nodes(ctx context.Context, params DELETEV1NodesParams) (res *GenericResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/nodes"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "nodeset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "nodeset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Nodeset.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "tags" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "tags",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Tags.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Accept",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Accept.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityHeaderAuth(ctx, DELETEV1NodesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HeaderAuth\"")
			}
		}
		{

			switch err := c.securityCookieAuth(ctx, DELETEV1NodesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDELETEV1NodesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DELETEV1RolesNames invokes DELETE_/v1/roles/:names operation.
//
// #### Controller:
// `github.com/ubccr/grendel/internal/api.(*Handler).DeleteRoles`
// #### Middlewares:
// - `github.com/go-fuego/fuego.defaultLogger.middleware`
// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
// ---
// Delete roles.
//
// DELETE /v1/roles/{names}
func (c *Client) DELETEV1RolesNames(ctx context.Context, params DELETEV1RolesNamesParams) (*GenericResponse, error) {
	res, err := c.sendDELETEV1RolesNames(ctx, params)
	return res, err
}

func (c *Client) sendDELETEV1RolesNames(ctx context.Context, params DELETEV1RolesNamesParams) (res *GenericResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/roles/"
	{
		// Encode "names" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "names",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Names))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Accept",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Accept.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityHeaderAuth(ctx, DELETEV1RolesNamesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HeaderAuth\"")
			}
		}
		{

			switch err := c.securityCookieAuth(ctx, DELETEV1RolesNamesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDELETEV1RolesNamesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DELETEV1UsersUsernames invokes DELETE_/v1/users/:usernames operation.
//
// #### Controller:
// `github.com/ubccr/grendel/internal/api.(*Handler).UserDelete`
// #### Middlewares:
// - `github.com/go-fuego/fuego.defaultLogger.middleware`
// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
// ---
// Delete users.
//
// DELETE /v1/users/{usernames}
func (c *Client) DELETEV1UsersUsernames(ctx context.Context, params DELETEV1UsersUsernamesParams) (*GenericResponse, error) {
	res, err := c.sendDELETEV1UsersUsernames(ctx, params)
	return res, err
}

func (c *Client) sendDELETEV1UsersUsernames(ctx context.Context, params DELETEV1UsersUsernamesParams) (res *GenericResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/users/"
	{
		// Encode "usernames" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "usernames",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Usernames))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Accept",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Accept.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityHeaderAuth(ctx, DELETEV1UsersUsernamesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HeaderAuth\"")
			}
		}
		{

			switch err := c.securityCookieAuth(ctx, DELETEV1UsersUsernamesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDELETEV1UsersUsernamesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GETV1Bmc invokes GET_/v1/bmc operation.
//
// #### Controller:
// `github.com/ubccr/grendel/internal/api.(*Handler).BmcQuery`
// #### Middlewares:
// - `github.com/go-fuego/fuego.defaultLogger.middleware`
// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
// ---
// Get redfish info from node(s).
//
// GET /v1/bmc
func (c *Client) GETV1Bmc(ctx context.Context, params GETV1BmcParams) ([]RedfishSystem, error) {
	res, err := c.sendGETV1Bmc(ctx, params)
	return res, err
}

func (c *Client) sendGETV1Bmc(ctx context.Context, params GETV1BmcParams) (res []RedfishSystem, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/bmc"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "nodeset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "nodeset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Nodeset.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "tags" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "tags",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Tags.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Accept",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Accept.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityHeaderAuth(ctx, GETV1BmcOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HeaderAuth\"")
			}
		}
		{

			switch err := c.securityCookieAuth(ctx, GETV1BmcOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGETV1BmcResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GETV1BmcJobs invokes GET_/v1/bmc/jobs operation.
//
// #### Controller:
// `github.com/ubccr/grendel/internal/api.(*Handler).BmcJobList`
// #### Middlewares:
// - `github.com/go-fuego/fuego.defaultLogger.middleware`
// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
// ---
// Get redfish jobs from node(s).
//
// GET /v1/bmc/jobs
func (c *Client) GETV1BmcJobs(ctx context.Context, params GETV1BmcJobsParams) ([]RedfishJob, error) {
	res, err := c.sendGETV1BmcJobs(ctx, params)
	return res, err
}

func (c *Client) sendGETV1BmcJobs(ctx context.Context, params GETV1BmcJobsParams) (res []RedfishJob, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/bmc/jobs"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "nodeset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "nodeset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Nodeset.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "tags" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "tags",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Tags.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Accept",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Accept.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityHeaderAuth(ctx, GETV1BmcJobsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HeaderAuth\"")
			}
		}
		{

			switch err := c.securityCookieAuth(ctx, GETV1BmcJobsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGETV1BmcJobsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GETV1BmcMetrics invokes GET_/v1/bmc/metrics operation.
//
// #### Controller:
// `github.com/ubccr/grendel/internal/api.(*Handler).BmcMetricReports`
// #### Middlewares:
// - `github.com/go-fuego/fuego.defaultLogger.middleware`
// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
// ---
// Get metric reports by nodeset.
//
// GET /v1/bmc/metrics
func (c *Client) GETV1BmcMetrics(ctx context.Context, params GETV1BmcMetricsParams) ([]RedfishMetricReport, error) {
	res, err := c.sendGETV1BmcMetrics(ctx, params)
	return res, err
}

func (c *Client) sendGETV1BmcMetrics(ctx context.Context, params GETV1BmcMetricsParams) (res []RedfishMetricReport, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/bmc/metrics"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "nodeset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "nodeset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Nodeset.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "tags" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "tags",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Tags.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Accept",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Accept.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityHeaderAuth(ctx, GETV1BmcMetricsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HeaderAuth\"")
			}
		}
		{

			switch err := c.securityCookieAuth(ctx, GETV1BmcMetricsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGETV1BmcMetricsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GETV1DbDump invokes GET_/v1/db/dump operation.
//
// #### Controller:
// `github.com/ubccr/grendel/internal/api.(*Handler).Dump`
// #### Middlewares:
// - `github.com/go-fuego/fuego.defaultLogger.middleware`
// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
// ---
// Get a backup of the DB.
//
// GET /v1/db/dump
func (c *Client) GETV1DbDump(ctx context.Context, params GETV1DbDumpParams) (*DataDump, error) {
	res, err := c.sendGETV1DbDump(ctx, params)
	return res, err
}

func (c *Client) sendGETV1DbDump(ctx context.Context, params GETV1DbDumpParams) (res *DataDump, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/db/dump"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Accept",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Accept.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityHeaderAuth(ctx, GETV1DbDumpOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HeaderAuth\"")
			}
		}
		{

			switch err := c.securityCookieAuth(ctx, GETV1DbDumpOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGETV1DbDumpResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GETV1GrendelEvents invokes GET_/v1/grendel/events operation.
//
// #### Controller:
// `github.com/ubccr/grendel/internal/api.(*Handler).GetEvents`
// #### Middlewares:
// - `github.com/go-fuego/fuego.defaultLogger.middleware`
// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
// ---.
//
// GET /v1/grendel/events
func (c *Client) GETV1GrendelEvents(ctx context.Context, params GETV1GrendelEventsParams) ([]Event, error) {
	res, err := c.sendGETV1GrendelEvents(ctx, params)
	return res, err
}

func (c *Client) sendGETV1GrendelEvents(ctx context.Context, params GETV1GrendelEventsParams) (res []Event, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/grendel/events"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Accept",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Accept.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityHeaderAuth(ctx, GETV1GrendelEventsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HeaderAuth\"")
			}
		}
		{

			switch err := c.securityCookieAuth(ctx, GETV1GrendelEventsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGETV1GrendelEventsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GETV1Images invokes GET_/v1/images operation.
//
// #### Controller:
// `github.com/ubccr/grendel/internal/api.(*Handler).BootImageList`
// #### Middlewares:
// - `github.com/go-fuego/fuego.defaultLogger.middleware`
// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
// ---
// List all images.
//
// GET /v1/images
func (c *Client) GETV1Images(ctx context.Context, params GETV1ImagesParams) ([]BootImage, error) {
	res, err := c.sendGETV1Images(ctx, params)
	return res, err
}

func (c *Client) sendGETV1Images(ctx context.Context, params GETV1ImagesParams) (res []BootImage, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/images"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Accept",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Accept.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityHeaderAuth(ctx, GETV1ImagesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HeaderAuth\"")
			}
		}
		{

			switch err := c.securityCookieAuth(ctx, GETV1ImagesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGETV1ImagesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GETV1ImagesFind invokes GET_/v1/images/find operation.
//
// #### Controller:
// `github.com/ubccr/grendel/internal/api.(*Handler).BootImageFind`
// #### Middlewares:
// - `github.com/go-fuego/fuego.defaultLogger.middleware`
// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
// ---
// Find images by name.
//
// GET /v1/images/find
func (c *Client) GETV1ImagesFind(ctx context.Context, params GETV1ImagesFindParams) ([]BootImage, error) {
	res, err := c.sendGETV1ImagesFind(ctx, params)
	return res, err
}

func (c *Client) sendGETV1ImagesFind(ctx context.Context, params GETV1ImagesFindParams) (res []BootImage, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/images/find"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "names" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "names",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Names.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Accept",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Accept.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityHeaderAuth(ctx, GETV1ImagesFindOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HeaderAuth\"")
			}
		}
		{

			switch err := c.securityCookieAuth(ctx, GETV1ImagesFindOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGETV1ImagesFindResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GETV1Nodes invokes GET_/v1/nodes operation.
//
// #### Controller:
// `github.com/ubccr/grendel/internal/api.(*Handler).NodeList`
// #### Middlewares:
// - `github.com/go-fuego/fuego.defaultLogger.middleware`
// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
// ---
// List all nodes.
//
// GET /v1/nodes
func (c *Client) GETV1Nodes(ctx context.Context, params GETV1NodesParams) ([]Host, error) {
	res, err := c.sendGETV1Nodes(ctx, params)
	return res, err
}

func (c *Client) sendGETV1Nodes(ctx context.Context, params GETV1NodesParams) (res []Host, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/nodes"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Accept",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Accept.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityHeaderAuth(ctx, GETV1NodesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HeaderAuth\"")
			}
		}
		{

			switch err := c.securityCookieAuth(ctx, GETV1NodesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGETV1NodesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GETV1NodesFind invokes GET_/v1/nodes/find operation.
//
// #### Controller:
// `github.com/ubccr/grendel/internal/api.(*Handler).NodeFind`
// #### Middlewares:
// - `github.com/go-fuego/fuego.defaultLogger.middleware`
// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
// ---
// Find nodes by nodeset and/or tags.
//
// GET /v1/nodes/find
func (c *Client) GETV1NodesFind(ctx context.Context, params GETV1NodesFindParams) ([]Host, error) {
	res, err := c.sendGETV1NodesFind(ctx, params)
	return res, err
}

func (c *Client) sendGETV1NodesFind(ctx context.Context, params GETV1NodesFindParams) (res []Host, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/nodes/find"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "nodeset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "nodeset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Nodeset.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "tags" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "tags",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Tags.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Accept",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Accept.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityHeaderAuth(ctx, GETV1NodesFindOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HeaderAuth\"")
			}
		}
		{

			switch err := c.securityCookieAuth(ctx, GETV1NodesFindOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGETV1NodesFindResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GETV1NodesTokenInterface invokes GET_/v1/nodes/token/:interface operation.
//
// #### Controller:
// `github.com/ubccr/grendel/internal/api.(*Handler).NodeBootToken`
// #### Middlewares:
// - `github.com/go-fuego/fuego.defaultLogger.middleware`
// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
// ---
// Create a boot token for the provision server. Used for debugging requests made by images.
//
// GET /v1/nodes/token/{interface}
func (c *Client) GETV1NodesTokenInterface(ctx context.Context, params GETV1NodesTokenInterfaceParams) (*NodeBootTokenResponse, error) {
	res, err := c.sendGETV1NodesTokenInterface(ctx, params)
	return res, err
}

func (c *Client) sendGETV1NodesTokenInterface(ctx context.Context, params GETV1NodesTokenInterfaceParams) (res *NodeBootTokenResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/nodes/token/"
	{
		// Encode "interface" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "interface",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Interface))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "nodeset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "nodeset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Nodeset.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "tags" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "tags",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Tags.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Accept",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Accept.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityHeaderAuth(ctx, GETV1NodesTokenInterfaceOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HeaderAuth\"")
			}
		}
		{

			switch err := c.securityCookieAuth(ctx, GETV1NodesTokenInterfaceOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGETV1NodesTokenInterfaceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GETV1Roles invokes GET_/v1/roles operation.
//
// #### Controller:
// `github.com/ubccr/grendel/internal/api.(*Handler).GetRoles`
// #### Middlewares:
// - `github.com/go-fuego/fuego.defaultLogger.middleware`
// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
// ---
// Get roles and permissions.
//
// GET /v1/roles
func (c *Client) GETV1Roles(ctx context.Context, params GETV1RolesParams) (*GetRolesResponse, error) {
	res, err := c.sendGETV1Roles(ctx, params)
	return res, err
}

func (c *Client) sendGETV1Roles(ctx context.Context, params GETV1RolesParams) (res *GetRolesResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/roles"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Name.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Accept",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Accept.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityHeaderAuth(ctx, GETV1RolesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HeaderAuth\"")
			}
		}
		{

			switch err := c.securityCookieAuth(ctx, GETV1RolesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGETV1RolesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GETV1SwitchNodesetLldp invokes GET_/v1/switch/:nodeset/lldp operation.
//
// #### Controller:
// `github.com/ubccr/grendel/internal/api.(*Handler).SwitchGetLLDP`
// #### Middlewares:
// - `github.com/go-fuego/fuego.defaultLogger.middleware`
// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
// ---
// Get switch LLDP info.
//
// GET /v1/switch/{nodeset}/lldp
func (c *Client) GETV1SwitchNodesetLldp(ctx context.Context, params GETV1SwitchNodesetLldpParams) ([]LLDP, error) {
	res, err := c.sendGETV1SwitchNodesetLldp(ctx, params)
	return res, err
}

func (c *Client) sendGETV1SwitchNodesetLldp(ctx context.Context, params GETV1SwitchNodesetLldpParams) (res []LLDP, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/switch/"
	{
		// Encode "nodeset" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "nodeset",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Nodeset))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/lldp"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "ports" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "ports",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Ports.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Accept",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Accept.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityHeaderAuth(ctx, GETV1SwitchNodesetLldpOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HeaderAuth\"")
			}
		}
		{

			switch err := c.securityCookieAuth(ctx, GETV1SwitchNodesetLldpOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGETV1SwitchNodesetLldpResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GETV1Users invokes GET_/v1/users operation.
//
// #### Controller:
// `github.com/ubccr/grendel/internal/api.(*Handler).UserList`
// #### Middlewares:
// - `github.com/go-fuego/fuego.defaultLogger.middleware`
// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
// ---
// List all users.
//
// GET /v1/users
func (c *Client) GETV1Users(ctx context.Context, params GETV1UsersParams) ([]User, error) {
	res, err := c.sendGETV1Users(ctx, params)
	return res, err
}

func (c *Client) sendGETV1Users(ctx context.Context, params GETV1UsersParams) (res []User, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/users"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "usernames" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "usernames",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Usernames.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Accept",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Accept.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityHeaderAuth(ctx, GETV1UsersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HeaderAuth\"")
			}
		}
		{

			switch err := c.securityCookieAuth(ctx, GETV1UsersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGETV1UsersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PATCHV1AuthReset invokes PATCH_/v1/auth/reset operation.
//
// #### Controller:
// `github.com/ubccr/grendel/internal/api.(*Handler).AuthReset`
// #### Middlewares:
// - `github.com/go-fuego/fuego.defaultLogger.middleware`
// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
// ---
// Change password.
//
// PATCH /v1/auth/reset
func (c *Client) PATCHV1AuthReset(ctx context.Context, request *AuthResetRequest, params PATCHV1AuthResetParams) (*GenericResponse, error) {
	res, err := c.sendPATCHV1AuthReset(ctx, request, params)
	return res, err
}

func (c *Client) sendPATCHV1AuthReset(ctx context.Context, request *AuthResetRequest, params PATCHV1AuthResetParams) (res *GenericResponse, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/auth/reset"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePATCHV1AuthResetRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Accept",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Accept.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityHeaderAuth(ctx, PATCHV1AuthResetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HeaderAuth\"")
			}
		}
		{

			switch err := c.securityCookieAuth(ctx, PATCHV1AuthResetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePATCHV1AuthResetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PATCHV1NodesImage invokes PATCH_/v1/nodes/image operation.
//
// #### Controller:
// `github.com/ubccr/grendel/internal/api.(*Handler).NodeBootImage`
// #### Middlewares:
// - `github.com/go-fuego/fuego.defaultLogger.middleware`
// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
// ---
// Update nodes boot image by nodeset and/or tags.
//
// PATCH /v1/nodes/image
func (c *Client) PATCHV1NodesImage(ctx context.Context, request *NodeBootImageRequest, params PATCHV1NodesImageParams) (*GenericResponse, error) {
	res, err := c.sendPATCHV1NodesImage(ctx, request, params)
	return res, err
}

func (c *Client) sendPATCHV1NodesImage(ctx context.Context, request *NodeBootImageRequest, params PATCHV1NodesImageParams) (res *GenericResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/nodes/image"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "nodeset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "nodeset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Nodeset.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "tags" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "tags",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Tags.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePATCHV1NodesImageRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Accept",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Accept.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityHeaderAuth(ctx, PATCHV1NodesImageOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HeaderAuth\"")
			}
		}
		{

			switch err := c.securityCookieAuth(ctx, PATCHV1NodesImageOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePATCHV1NodesImageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PATCHV1NodesProvision invokes PATCH_/v1/nodes/provision operation.
//
// #### Controller:
// `github.com/ubccr/grendel/internal/api.(*Handler).NodeProvision`
// #### Middlewares:
// - `github.com/go-fuego/fuego.defaultLogger.middleware`
// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
// ---
// Provision / Unprovision nodes by nodeset and/or tags.
//
// PATCH /v1/nodes/provision
func (c *Client) PATCHV1NodesProvision(ctx context.Context, request *NodeProvisionRequest, params PATCHV1NodesProvisionParams) (*GenericResponse, error) {
	res, err := c.sendPATCHV1NodesProvision(ctx, request, params)
	return res, err
}

func (c *Client) sendPATCHV1NodesProvision(ctx context.Context, request *NodeProvisionRequest, params PATCHV1NodesProvisionParams) (res *GenericResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/nodes/provision"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "nodeset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "nodeset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Nodeset.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "tags" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "tags",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Tags.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePATCHV1NodesProvisionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Accept",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Accept.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityHeaderAuth(ctx, PATCHV1NodesProvisionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HeaderAuth\"")
			}
		}
		{

			switch err := c.securityCookieAuth(ctx, PATCHV1NodesProvisionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePATCHV1NodesProvisionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PATCHV1NodesTagsAction invokes PATCH_/v1/nodes/tags/:action operation.
//
// #### Controller:
// `github.com/ubccr/grendel/internal/api.(*Handler).NodeTags`
// #### Middlewares:
// - `github.com/go-fuego/fuego.defaultLogger.middleware`
// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
// ---
// Update nodes tags by nodeset and/or tags.
//
// PATCH /v1/nodes/tags/{action}
func (c *Client) PATCHV1NodesTagsAction(ctx context.Context, request *NodeTagsRequest, params PATCHV1NodesTagsActionParams) (*GenericResponse, error) {
	res, err := c.sendPATCHV1NodesTagsAction(ctx, request, params)
	return res, err
}

func (c *Client) sendPATCHV1NodesTagsAction(ctx context.Context, request *NodeTagsRequest, params PATCHV1NodesTagsActionParams) (res *GenericResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/nodes/tags/"
	{
		// Encode "action" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "action",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Action))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "nodeset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "nodeset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Nodeset.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "tags" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "tags",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Tags.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePATCHV1NodesTagsActionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Accept",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Accept.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityHeaderAuth(ctx, PATCHV1NodesTagsActionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HeaderAuth\"")
			}
		}
		{

			switch err := c.securityCookieAuth(ctx, PATCHV1NodesTagsActionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePATCHV1NodesTagsActionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PATCHV1Roles invokes PATCH_/v1/roles operation.
//
// #### Controller:
// `github.com/ubccr/grendel/internal/api.(*Handler).PatchRoles`
// #### Middlewares:
// - `github.com/go-fuego/fuego.defaultLogger.middleware`
// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
// ---
// Edit role permissions.
//
// PATCH /v1/roles
func (c *Client) PATCHV1Roles(ctx context.Context, request *PatchRolesRequest, params PATCHV1RolesParams) (*GenericResponse, error) {
	res, err := c.sendPATCHV1Roles(ctx, request, params)
	return res, err
}

func (c *Client) sendPATCHV1Roles(ctx context.Context, request *PatchRolesRequest, params PATCHV1RolesParams) (res *GenericResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/roles"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePATCHV1RolesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Accept",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Accept.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityHeaderAuth(ctx, PATCHV1RolesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HeaderAuth\"")
			}
		}
		{

			switch err := c.securityCookieAuth(ctx, PATCHV1RolesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePATCHV1RolesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PATCHV1UsersUsernamesEnable invokes PATCH_/v1/users/:usernames/enable operation.
//
// #### Controller:
// `github.com/ubccr/grendel/internal/api.(*Handler).UserEnable`
// #### Middlewares:
// - `github.com/go-fuego/fuego.defaultLogger.middleware`
// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
// ---
// Update users enable.
//
// PATCH /v1/users/{usernames}/enable
func (c *Client) PATCHV1UsersUsernamesEnable(ctx context.Context, request *UserEnableRequest, params PATCHV1UsersUsernamesEnableParams) (*GenericResponse, error) {
	res, err := c.sendPATCHV1UsersUsernamesEnable(ctx, request, params)
	return res, err
}

func (c *Client) sendPATCHV1UsersUsernamesEnable(ctx context.Context, request *UserEnableRequest, params PATCHV1UsersUsernamesEnableParams) (res *GenericResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/users/"
	{
		// Encode "usernames" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "usernames",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Usernames))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/enable"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePATCHV1UsersUsernamesEnableRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Accept",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Accept.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityHeaderAuth(ctx, PATCHV1UsersUsernamesEnableOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HeaderAuth\"")
			}
		}
		{

			switch err := c.securityCookieAuth(ctx, PATCHV1UsersUsernamesEnableOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePATCHV1UsersUsernamesEnableResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PATCHV1UsersUsernamesRole invokes PATCH_/v1/users/:usernames/role operation.
//
// #### Controller:
// `github.com/ubccr/grendel/internal/api.(*Handler).UserRole`
// #### Middlewares:
// - `github.com/go-fuego/fuego.defaultLogger.middleware`
// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
// ---
// Update users role.
//
// PATCH /v1/users/{usernames}/role
func (c *Client) PATCHV1UsersUsernamesRole(ctx context.Context, request *UserRoleRequest, params PATCHV1UsersUsernamesRoleParams) (*GenericResponse, error) {
	res, err := c.sendPATCHV1UsersUsernamesRole(ctx, request, params)
	return res, err
}

func (c *Client) sendPATCHV1UsersUsernamesRole(ctx context.Context, request *UserRoleRequest, params PATCHV1UsersUsernamesRoleParams) (res *GenericResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/users/"
	{
		// Encode "usernames" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "usernames",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Usernames))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/role"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePATCHV1UsersUsernamesRoleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Accept",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Accept.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityHeaderAuth(ctx, PATCHV1UsersUsernamesRoleOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HeaderAuth\"")
			}
		}
		{

			switch err := c.securityCookieAuth(ctx, PATCHV1UsersUsernamesRoleOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePATCHV1UsersUsernamesRoleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// POSTV1AuthSignin invokes POST_/v1/auth/signin operation.
//
// #### Controller:
// `github.com/ubccr/grendel/internal/api.(*Handler).AuthSignin`
// #### Middlewares:
// - `github.com/go-fuego/fuego.defaultLogger.middleware`
// ---
// signin user.
//
// POST /v1/auth/signin
func (c *Client) POSTV1AuthSignin(ctx context.Context, request *AuthRequest, params POSTV1AuthSigninParams) (*AuthResponse, error) {
	res, err := c.sendPOSTV1AuthSignin(ctx, request, params)
	return res, err
}

func (c *Client) sendPOSTV1AuthSignin(ctx context.Context, request *AuthRequest, params POSTV1AuthSigninParams) (res *AuthResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/auth/signin"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePOSTV1AuthSigninRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Accept",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Accept.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityHeaderAuth(ctx, POSTV1AuthSigninOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HeaderAuth\"")
			}
		}
		{

			switch err := c.securityCookieAuth(ctx, POSTV1AuthSigninOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePOSTV1AuthSigninResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// POSTV1AuthSignup invokes POST_/v1/auth/signup operation.
//
// #### Controller:
// `github.com/ubccr/grendel/internal/api.(*Handler).AuthSignup`
// #### Middlewares:
// - `github.com/go-fuego/fuego.defaultLogger.middleware`
// ---
// Signup user.
//
// POST /v1/auth/signup
func (c *Client) POSTV1AuthSignup(ctx context.Context, request *AuthSignupRequest, params POSTV1AuthSignupParams) (*AuthResponse, error) {
	res, err := c.sendPOSTV1AuthSignup(ctx, request, params)
	return res, err
}

func (c *Client) sendPOSTV1AuthSignup(ctx context.Context, request *AuthSignupRequest, params POSTV1AuthSignupParams) (res *AuthResponse, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/auth/signup"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePOSTV1AuthSignupRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Accept",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Accept.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityHeaderAuth(ctx, POSTV1AuthSignupOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HeaderAuth\"")
			}
		}
		{

			switch err := c.securityCookieAuth(ctx, POSTV1AuthSignupOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePOSTV1AuthSignupResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// POSTV1AuthToken invokes POST_/v1/auth/token operation.
//
// #### Controller:
// `github.com/ubccr/grendel/internal/api.(*Handler).AuthToken`
// #### Middlewares:
// - `github.com/go-fuego/fuego.defaultLogger.middleware`
// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
// ---
// Create API token.
//
// POST /v1/auth/token
func (c *Client) POSTV1AuthToken(ctx context.Context, request *AuthTokenRequest, params POSTV1AuthTokenParams) (*AuthTokenReponse, error) {
	res, err := c.sendPOSTV1AuthToken(ctx, request, params)
	return res, err
}

func (c *Client) sendPOSTV1AuthToken(ctx context.Context, request *AuthTokenRequest, params POSTV1AuthTokenParams) (res *AuthTokenReponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/auth/token"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePOSTV1AuthTokenRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Accept",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Accept.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityHeaderAuth(ctx, POSTV1AuthTokenOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HeaderAuth\"")
			}
		}
		{

			switch err := c.securityCookieAuth(ctx, POSTV1AuthTokenOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePOSTV1AuthTokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// POSTV1BmcConfigureAuto invokes POST_/v1/bmc/configure/auto operation.
//
// #### Controller:
// `github.com/ubccr/grendel/internal/api.(*Handler).BmcAutoConfigure`
// #### Middlewares:
// - `github.com/go-fuego/fuego.defaultLogger.middleware`
// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
// ---
// Set BMC to autoconfigure.
//
// POST /v1/bmc/configure/auto
func (c *Client) POSTV1BmcConfigureAuto(ctx context.Context, params POSTV1BmcConfigureAutoParams) ([]JobMessage, error) {
	res, err := c.sendPOSTV1BmcConfigureAuto(ctx, params)
	return res, err
}

func (c *Client) sendPOSTV1BmcConfigureAuto(ctx context.Context, params POSTV1BmcConfigureAutoParams) (res []JobMessage, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/bmc/configure/auto"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "nodeset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "nodeset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Nodeset.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "tags" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "tags",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Tags.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Accept",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Accept.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityHeaderAuth(ctx, POSTV1BmcConfigureAutoOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HeaderAuth\"")
			}
		}
		{

			switch err := c.securityCookieAuth(ctx, POSTV1BmcConfigureAutoOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePOSTV1BmcConfigureAutoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// POSTV1BmcConfigureImport invokes POST_/v1/bmc/configure/import operation.
//
// #### Controller:
// `github.com/ubccr/grendel/internal/api.(*Handler).BmcImportConfiguration`
// #### Middlewares:
// - `github.com/go-fuego/fuego.defaultLogger.middleware`
// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
// ---
// Manually import system configuration to BMC.
//
// POST /v1/bmc/configure/import
func (c *Client) POSTV1BmcConfigureImport(ctx context.Context, request *BmcImportConfigurationRequest, params POSTV1BmcConfigureImportParams) ([]JobMessage, error) {
	res, err := c.sendPOSTV1BmcConfigureImport(ctx, request, params)
	return res, err
}

func (c *Client) sendPOSTV1BmcConfigureImport(ctx context.Context, request *BmcImportConfigurationRequest, params POSTV1BmcConfigureImportParams) (res []JobMessage, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/bmc/configure/import"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "nodeset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "nodeset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Nodeset.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "tags" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "tags",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Tags.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePOSTV1BmcConfigureImportRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Accept",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Accept.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityHeaderAuth(ctx, POSTV1BmcConfigureImportOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HeaderAuth\"")
			}
		}
		{

			switch err := c.securityCookieAuth(ctx, POSTV1BmcConfigureImportOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePOSTV1BmcConfigureImportResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// POSTV1BmcPowerBmc invokes POST_/v1/bmc/power/bmc operation.
//
// #### Controller:
// `github.com/ubccr/grendel/internal/api.(*Handler).BmcPower`
// #### Middlewares:
// - `github.com/go-fuego/fuego.defaultLogger.middleware`
// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
// ---
// Reboot node(s) BMC.
//
// POST /v1/bmc/power/bmc
func (c *Client) POSTV1BmcPowerBmc(ctx context.Context, params POSTV1BmcPowerBmcParams) ([]JobMessage, error) {
	res, err := c.sendPOSTV1BmcPowerBmc(ctx, params)
	return res, err
}

func (c *Client) sendPOSTV1BmcPowerBmc(ctx context.Context, params POSTV1BmcPowerBmcParams) (res []JobMessage, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/bmc/power/bmc"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "nodeset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "nodeset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Nodeset.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "tags" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "tags",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Tags.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Accept",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Accept.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityHeaderAuth(ctx, POSTV1BmcPowerBmcOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HeaderAuth\"")
			}
		}
		{

			switch err := c.securityCookieAuth(ctx, POSTV1BmcPowerBmcOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePOSTV1BmcPowerBmcResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// POSTV1BmcPowerOs invokes POST_/v1/bmc/power/os operation.
//
// #### Controller:
// `github.com/ubccr/grendel/internal/api.(*Handler).BmcOsPower`
// #### Middlewares:
// - `github.com/go-fuego/fuego.defaultLogger.middleware`
// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
// ---
// Change power status of node(s).
//
// POST /v1/bmc/power/os
func (c *Client) POSTV1BmcPowerOs(ctx context.Context, request *BmcOsPowerBody, params POSTV1BmcPowerOsParams) ([]JobMessage, error) {
	res, err := c.sendPOSTV1BmcPowerOs(ctx, request, params)
	return res, err
}

func (c *Client) sendPOSTV1BmcPowerOs(ctx context.Context, request *BmcOsPowerBody, params POSTV1BmcPowerOsParams) (res []JobMessage, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/bmc/power/os"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "nodeset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "nodeset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Nodeset.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "tags" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "tags",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Tags.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePOSTV1BmcPowerOsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Accept",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Accept.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityHeaderAuth(ctx, POSTV1BmcPowerOsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HeaderAuth\"")
			}
		}
		{

			switch err := c.securityCookieAuth(ctx, POSTV1BmcPowerOsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePOSTV1BmcPowerOsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// POSTV1DbRestore invokes POST_/v1/db/restore operation.
//
// #### Controller:
// `github.com/ubccr/grendel/internal/api.(*Handler).Restore`
// #### Middlewares:
// - `github.com/go-fuego/fuego.defaultLogger.middleware`
// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
// ---
// Restore a backup of the DB.
//
// POST /v1/db/restore
func (c *Client) POSTV1DbRestore(ctx context.Context, request *DataDump, params POSTV1DbRestoreParams) (*GenericResponse, error) {
	res, err := c.sendPOSTV1DbRestore(ctx, request, params)
	return res, err
}

func (c *Client) sendPOSTV1DbRestore(ctx context.Context, request *DataDump, params POSTV1DbRestoreParams) (res *GenericResponse, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/db/restore"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePOSTV1DbRestoreRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Accept",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Accept.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityHeaderAuth(ctx, POSTV1DbRestoreOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HeaderAuth\"")
			}
		}
		{

			switch err := c.securityCookieAuth(ctx, POSTV1DbRestoreOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePOSTV1DbRestoreResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// POSTV1Images invokes POST_/v1/images operation.
//
// #### Controller:
// `github.com/ubccr/grendel/internal/api.(*Handler).BootImageAdd`
// #### Middlewares:
// - `github.com/go-fuego/fuego.defaultLogger.middleware`
// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
// ---
// Add images.
//
// POST /v1/images
func (c *Client) POSTV1Images(ctx context.Context, request *BootImageAddRequest, params POSTV1ImagesParams) (*GenericResponse, error) {
	res, err := c.sendPOSTV1Images(ctx, request, params)
	return res, err
}

func (c *Client) sendPOSTV1Images(ctx context.Context, request *BootImageAddRequest, params POSTV1ImagesParams) (res *GenericResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/images"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePOSTV1ImagesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Accept",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Accept.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityHeaderAuth(ctx, POSTV1ImagesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HeaderAuth\"")
			}
		}
		{

			switch err := c.securityCookieAuth(ctx, POSTV1ImagesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePOSTV1ImagesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// POSTV1Nodes invokes POST_/v1/nodes operation.
//
// #### Controller:
// `github.com/ubccr/grendel/internal/api.(*Handler).NodeAdd`
// #### Middlewares:
// - `github.com/go-fuego/fuego.defaultLogger.middleware`
// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
// ---
// Add nodes.
//
// POST /v1/nodes
func (c *Client) POSTV1Nodes(ctx context.Context, request *NodeAddRequest, params POSTV1NodesParams) (*GenericResponse, error) {
	res, err := c.sendPOSTV1Nodes(ctx, request, params)
	return res, err
}

func (c *Client) sendPOSTV1Nodes(ctx context.Context, request *NodeAddRequest, params POSTV1NodesParams) (res *GenericResponse, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/nodes"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePOSTV1NodesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Accept",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Accept.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityHeaderAuth(ctx, POSTV1NodesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HeaderAuth\"")
			}
		}
		{

			switch err := c.securityCookieAuth(ctx, POSTV1NodesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePOSTV1NodesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// POSTV1Roles invokes POST_/v1/roles operation.
//
// #### Controller:
// `github.com/ubccr/grendel/internal/api.(*Handler).PostRoles`
// #### Middlewares:
// - `github.com/go-fuego/fuego.defaultLogger.middleware`
// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
// ---
// Add roles.
//
// POST /v1/roles
func (c *Client) POSTV1Roles(ctx context.Context, request *PostRolesRequest, params POSTV1RolesParams) (*GenericResponse, error) {
	res, err := c.sendPOSTV1Roles(ctx, request, params)
	return res, err
}

func (c *Client) sendPOSTV1Roles(ctx context.Context, request *PostRolesRequest, params POSTV1RolesParams) (res *GenericResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/roles"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePOSTV1RolesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Accept",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Accept.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityHeaderAuth(ctx, POSTV1RolesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HeaderAuth\"")
			}
		}
		{

			switch err := c.securityCookieAuth(ctx, POSTV1RolesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePOSTV1RolesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// POSTV1Users invokes POST_/v1/users operation.
//
// #### Controller:
// `github.com/ubccr/grendel/internal/api.(*Handler).UserStore`
// #### Middlewares:
// - `github.com/go-fuego/fuego.defaultLogger.middleware`
// - `github.com/ubccr/grendel/internal/api.(*Handler).authMiddleware`
// ---
// Add new user.
//
// POST /v1/users
func (c *Client) POSTV1Users(ctx context.Context, request *UserStoreRequest, params POSTV1UsersParams) (*UserStoreResponse, error) {
	res, err := c.sendPOSTV1Users(ctx, request, params)
	return res, err
}

func (c *Client) sendPOSTV1Users(ctx context.Context, request *UserStoreRequest, params POSTV1UsersParams) (res *UserStoreResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/users"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePOSTV1UsersRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Accept",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Accept.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityHeaderAuth(ctx, POSTV1UsersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HeaderAuth\"")
			}
		}
		{

			switch err := c.securityCookieAuth(ctx, POSTV1UsersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CookieAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePOSTV1UsersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
