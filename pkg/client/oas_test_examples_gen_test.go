// Code generated by ogen, DO NOT EDIT.

package client

import (
	"github.com/go-faster/jx"

	std "encoding/json"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestAuthRequest_EncodeDecode(t *testing.T) {
	var typ AuthRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AuthRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAuthResetRequest_EncodeDecode(t *testing.T) {
	var typ AuthResetRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AuthResetRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAuthResponse_EncodeDecode(t *testing.T) {
	var typ AuthResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AuthResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAuthSignupRequest_EncodeDecode(t *testing.T) {
	var typ AuthSignupRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AuthSignupRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAuthTokenReponse_EncodeDecode(t *testing.T) {
	var typ AuthTokenReponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AuthTokenReponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAuthTokenRequest_EncodeDecode(t *testing.T) {
	var typ AuthTokenRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AuthTokenRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBmcDellInstallFromRepoRequest_EncodeDecode(t *testing.T) {
	var typ BmcDellInstallFromRepoRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BmcDellInstallFromRepoRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBmcImportConfigurationRequest_EncodeDecode(t *testing.T) {
	var typ BmcImportConfigurationRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BmcImportConfigurationRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBmcJobDeleteRequest_EncodeDecode(t *testing.T) {
	var typ BmcJobDeleteRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BmcJobDeleteRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBmcJobDeleteRequestNodeJobList_EncodeDecode(t *testing.T) {
	var typ BmcJobDeleteRequestNodeJobList
	typ = make(BmcJobDeleteRequestNodeJobList)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BmcJobDeleteRequestNodeJobList
	typ2 = make(BmcJobDeleteRequestNodeJobList)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBmcOsPowerBody_EncodeDecode(t *testing.T) {
	var typ BmcOsPowerBody
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BmcOsPowerBody
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBootImage_EncodeDecode(t *testing.T) {
	var typ BootImage
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BootImage
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBootImageAddRequest_EncodeDecode(t *testing.T) {
	var typ BootImageAddRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BootImageAddRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBootImageAddRequestBootImagesItem_EncodeDecode(t *testing.T) {
	var typ BootImageAddRequestBootImagesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BootImageAddRequestBootImagesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBootImageAddRequestBootImagesItemProvisionTemplates_EncodeDecode(t *testing.T) {
	var typ BootImageAddRequestBootImagesItemProvisionTemplates
	typ = make(BootImageAddRequestBootImagesItemProvisionTemplates)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BootImageAddRequestBootImagesItemProvisionTemplates
	typ2 = make(BootImageAddRequestBootImagesItemProvisionTemplates)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBootImageProvisionTemplates_EncodeDecode(t *testing.T) {
	var typ BootImageProvisionTemplates
	typ = make(BootImageProvisionTemplates)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BootImageProvisionTemplates
	typ2 = make(BootImageProvisionTemplates)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDataDump_EncodeDecode(t *testing.T) {
	var typ DataDump
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DataDump
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDataDumpHostsItem_EncodeDecode(t *testing.T) {
	var typ DataDumpHostsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DataDumpHostsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDataDumpHostsItemBondsItem_EncodeDecode(t *testing.T) {
	var typ DataDumpHostsItemBondsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DataDumpHostsItemBondsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDataDumpHostsItemInterfacesItem_EncodeDecode(t *testing.T) {
	var typ DataDumpHostsItemInterfacesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DataDumpHostsItemInterfacesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDataDumpImagesItem_EncodeDecode(t *testing.T) {
	var typ DataDumpImagesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DataDumpImagesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDataDumpImagesItemProvisionTemplates_EncodeDecode(t *testing.T) {
	var typ DataDumpImagesItemProvisionTemplates
	typ = make(DataDumpImagesItemProvisionTemplates)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DataDumpImagesItemProvisionTemplates
	typ2 = make(DataDumpImagesItemProvisionTemplates)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDataDumpUsersItem_EncodeDecode(t *testing.T) {
	var typ DataDumpUsersItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DataDumpUsersItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEvent_EncodeDecode(t *testing.T) {
	var typ Event
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Event
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEventJobMessagesItem_EncodeDecode(t *testing.T) {
	var typ EventJobMessagesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EventJobMessagesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEventJobMessagesItemRedfishError_EncodeDecode(t *testing.T) {
	var typ EventJobMessagesItemRedfishError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EventJobMessagesItemRedfishError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEventJobMessagesItemRedfishErrorError_EncodeDecode(t *testing.T) {
	var typ EventJobMessagesItemRedfishErrorError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EventJobMessagesItemRedfishErrorError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEventJobMessagesItemRedfishErrorErrorMessageDotExtendedInfoItem_EncodeDecode(t *testing.T) {
	var typ EventJobMessagesItemRedfishErrorErrorMessageDotExtendedInfoItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EventJobMessagesItemRedfishErrorErrorMessageDotExtendedInfoItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGenericResponse_EncodeDecode(t *testing.T) {
	var typ GenericResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GenericResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRolesResponse_EncodeDecode(t *testing.T) {
	var typ GetRolesResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRolesResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRolesResponseRolesItem_EncodeDecode(t *testing.T) {
	var typ GetRolesResponseRolesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRolesResponseRolesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRolesResponseRolesItemPermissionListItem_EncodeDecode(t *testing.T) {
	var typ GetRolesResponseRolesItemPermissionListItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRolesResponseRolesItemPermissionListItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRolesResponseRolesItemUnassignedPermissionListItem_EncodeDecode(t *testing.T) {
	var typ GetRolesResponseRolesItemUnassignedPermissionListItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRolesResponseRolesItemUnassignedPermissionListItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHTTPError_EncodeDecode(t *testing.T) {
	var typ HTTPError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HTTPError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHTTPErrorErrorsItem_EncodeDecode(t *testing.T) {
	var typ HTTPErrorErrorsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HTTPErrorErrorsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHTTPErrorErrorsItemMore_EncodeDecode(t *testing.T) {
	var typ HTTPErrorErrorsItemMore
	typ = make(HTTPErrorErrorsItemMore)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HTTPErrorErrorsItemMore
	typ2 = make(HTTPErrorErrorsItemMore)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHost_EncodeDecode(t *testing.T) {
	var typ Host
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Host
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHostBondsItem_EncodeDecode(t *testing.T) {
	var typ HostBondsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HostBondsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHostInterfacesItem_EncodeDecode(t *testing.T) {
	var typ HostInterfacesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HostInterfacesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestJobMessage_EncodeDecode(t *testing.T) {
	var typ JobMessage
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 JobMessage
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestJobMessageRedfishError_EncodeDecode(t *testing.T) {
	var typ JobMessageRedfishError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 JobMessageRedfishError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestJobMessageRedfishErrorError_EncodeDecode(t *testing.T) {
	var typ JobMessageRedfishErrorError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 JobMessageRedfishErrorError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestJobMessageRedfishErrorErrorMessageDotExtendedInfoItem_EncodeDecode(t *testing.T) {
	var typ JobMessageRedfishErrorErrorMessageDotExtendedInfoItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 JobMessageRedfishErrorErrorMessageDotExtendedInfoItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLLDP_EncodeDecode(t *testing.T) {
	var typ LLDP
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LLDP
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNodeAddRequest_EncodeDecode(t *testing.T) {
	var typ NodeAddRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NodeAddRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNodeAddRequestNodeListItem_EncodeDecode(t *testing.T) {
	var typ NodeAddRequestNodeListItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NodeAddRequestNodeListItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNodeAddRequestNodeListItemBondsItem_EncodeDecode(t *testing.T) {
	var typ NodeAddRequestNodeListItemBondsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NodeAddRequestNodeListItemBondsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNodeAddRequestNodeListItemInterfacesItem_EncodeDecode(t *testing.T) {
	var typ NodeAddRequestNodeListItemInterfacesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NodeAddRequestNodeListItemInterfacesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNodeBootImageRequest_EncodeDecode(t *testing.T) {
	var typ NodeBootImageRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NodeBootImageRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNodeBootTokenResponse_EncodeDecode(t *testing.T) {
	var typ NodeBootTokenResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NodeBootTokenResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNodeBootTokenResponseNodesItem_EncodeDecode(t *testing.T) {
	var typ NodeBootTokenResponseNodesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NodeBootTokenResponseNodesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNodeProvisionRequest_EncodeDecode(t *testing.T) {
	var typ NodeProvisionRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NodeProvisionRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNodeTagsRequest_EncodeDecode(t *testing.T) {
	var typ NodeTagsRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NodeTagsRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchRolesRequest_EncodeDecode(t *testing.T) {
	var typ PatchRolesRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchRolesRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchRolesRequestPermissionListItem_EncodeDecode(t *testing.T) {
	var typ PatchRolesRequestPermissionListItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchRolesRequestPermissionListItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostRolesRequest_EncodeDecode(t *testing.T) {
	var typ PostRolesRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostRolesRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRedfishDellUpgradeFirmware_EncodeDecode(t *testing.T) {
	var typ RedfishDellUpgradeFirmware
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RedfishDellUpgradeFirmware
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRedfishDellUpgradeFirmwareUpdateListItem_EncodeDecode(t *testing.T) {
	var typ RedfishDellUpgradeFirmwareUpdateListItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RedfishDellUpgradeFirmwareUpdateListItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRedfishJob_EncodeDecode(t *testing.T) {
	var typ RedfishJob
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RedfishJob
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRedfishJobJobsItem_EncodeDecode(t *testing.T) {
	var typ RedfishJobJobsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RedfishJobJobsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRedfishJobJobsItemMessageDotExtendedInfoItem_EncodeDecode(t *testing.T) {
	var typ RedfishJobJobsItemMessageDotExtendedInfoItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RedfishJobJobsItemMessageDotExtendedInfoItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRedfishJobJobsItemMessageDotExtendedInfoItemResolutionStepsItem_EncodeDecode(t *testing.T) {
	var typ RedfishJobJobsItemMessageDotExtendedInfoItemResolutionStepsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RedfishJobJobsItemMessageDotExtendedInfoItemResolutionStepsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRedfishJobJobsItemMessageDotExtendedInfoItemResolutionStepsItemActionParametersItem_EncodeDecode(t *testing.T) {
	var typ RedfishJobJobsItemMessageDotExtendedInfoItemResolutionStepsItemActionParametersItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RedfishJobJobsItemMessageDotExtendedInfoItemResolutionStepsItemActionParametersItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRedfishJobJobsItemMessagesItem_EncodeDecode(t *testing.T) {
	var typ RedfishJobJobsItemMessagesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RedfishJobJobsItemMessagesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRedfishJobJobsItemMessagesItemResolutionStepsItem_EncodeDecode(t *testing.T) {
	var typ RedfishJobJobsItemMessagesItemResolutionStepsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RedfishJobJobsItemMessagesItemResolutionStepsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRedfishJobJobsItemMessagesItemResolutionStepsItemActionParametersItem_EncodeDecode(t *testing.T) {
	var typ RedfishJobJobsItemMessagesItemResolutionStepsItemActionParametersItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RedfishJobJobsItemMessagesItemResolutionStepsItemActionParametersItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRedfishJobJobsItemParameters_EncodeDecode(t *testing.T) {
	var typ RedfishJobJobsItemParameters
	typ = make(RedfishJobJobsItemParameters)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RedfishJobJobsItemParameters
	typ2 = make(RedfishJobJobsItemParameters)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRedfishJobJobsItemPayload_EncodeDecode(t *testing.T) {
	var typ RedfishJobJobsItemPayload
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RedfishJobJobsItemPayload
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRedfishJobJobsItemSchedule_EncodeDecode(t *testing.T) {
	var typ RedfishJobJobsItemSchedule
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RedfishJobJobsItemSchedule
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRedfishMetricReport_EncodeDecode(t *testing.T) {
	var typ RedfishMetricReport
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RedfishMetricReport
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRedfishMetricReportReportsItem_EncodeDecode(t *testing.T) {
	var typ RedfishMetricReportReportsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RedfishMetricReportReportsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRedfishMetricReportReportsItemMessageDotExtendedInfoItem_EncodeDecode(t *testing.T) {
	var typ RedfishMetricReportReportsItemMessageDotExtendedInfoItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RedfishMetricReportReportsItemMessageDotExtendedInfoItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRedfishMetricReportReportsItemMessageDotExtendedInfoItemResolutionStepsItem_EncodeDecode(t *testing.T) {
	var typ RedfishMetricReportReportsItemMessageDotExtendedInfoItemResolutionStepsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RedfishMetricReportReportsItemMessageDotExtendedInfoItemResolutionStepsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRedfishMetricReportReportsItemMessageDotExtendedInfoItemResolutionStepsItemActionParametersItem_EncodeDecode(t *testing.T) {
	var typ RedfishMetricReportReportsItemMessageDotExtendedInfoItemResolutionStepsItemActionParametersItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RedfishMetricReportReportsItemMessageDotExtendedInfoItemResolutionStepsItemActionParametersItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRedfishMetricReportReportsItemMetricValuesItem_EncodeDecode(t *testing.T) {
	var typ RedfishMetricReportReportsItemMetricValuesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RedfishMetricReportReportsItemMetricValuesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRedfishSystem_EncodeDecode(t *testing.T) {
	var typ RedfishSystem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RedfishSystem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRedfishSystemOemDell_EncodeDecode(t *testing.T) {
	var typ RedfishSystemOemDell
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RedfishSystemOemDell
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRedfishSystemOemDellMessageDotExtendedInfoItem_EncodeDecode(t *testing.T) {
	var typ RedfishSystemOemDellMessageDotExtendedInfoItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RedfishSystemOemDellMessageDotExtendedInfoItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRedfishSystemOemDellMessageDotExtendedInfoItemResolutionStepsItem_EncodeDecode(t *testing.T) {
	var typ RedfishSystemOemDellMessageDotExtendedInfoItemResolutionStepsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RedfishSystemOemDellMessageDotExtendedInfoItemResolutionStepsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRedfishSystemOemDellMessageDotExtendedInfoItemResolutionStepsItemActionParametersItem_EncodeDecode(t *testing.T) {
	var typ RedfishSystemOemDellMessageDotExtendedInfoItemResolutionStepsItemActionParametersItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RedfishSystemOemDellMessageDotExtendedInfoItemResolutionStepsItemActionParametersItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUser_EncodeDecode(t *testing.T) {
	var typ User
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 User
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUserEnableRequest_EncodeDecode(t *testing.T) {
	var typ UserEnableRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UserEnableRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUserRoleRequest_EncodeDecode(t *testing.T) {
	var typ UserRoleRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UserRoleRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUserStoreRequest_EncodeDecode(t *testing.T) {
	var typ UserStoreRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UserStoreRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUserStoreResponse_EncodeDecode(t *testing.T) {
	var typ UserStoreResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UserStoreResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
