// Code generated by ogen, DO NOT EDIT.

package client

import (
	"github.com/go-faster/jx"

	std "encoding/json"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestAuthRequest_EncodeDecode(t *testing.T) {
	var typ AuthRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AuthRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAuthResponse_EncodeDecode(t *testing.T) {
	var typ AuthResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AuthResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAuthSignupRequest_EncodeDecode(t *testing.T) {
	var typ AuthSignupRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AuthSignupRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAuthTokenReponse_EncodeDecode(t *testing.T) {
	var typ AuthTokenReponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AuthTokenReponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAuthTokenRequest_EncodeDecode(t *testing.T) {
	var typ AuthTokenRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AuthTokenRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBmcImportConfigurationRequest_EncodeDecode(t *testing.T) {
	var typ BmcImportConfigurationRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BmcImportConfigurationRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBmcOsPowerBody_EncodeDecode(t *testing.T) {
	var typ BmcOsPowerBody
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BmcOsPowerBody
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBootImage_EncodeDecode(t *testing.T) {
	var typ BootImage
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BootImage
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBootImageAddRequest_EncodeDecode(t *testing.T) {
	var typ BootImageAddRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BootImageAddRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBootImageAddRequestBootImagesItem_EncodeDecode(t *testing.T) {
	var typ BootImageAddRequestBootImagesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BootImageAddRequestBootImagesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBootImageAddRequestBootImagesItemProvisionTemplates_EncodeDecode(t *testing.T) {
	var typ BootImageAddRequestBootImagesItemProvisionTemplates
	typ = make(BootImageAddRequestBootImagesItemProvisionTemplates)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BootImageAddRequestBootImagesItemProvisionTemplates
	typ2 = make(BootImageAddRequestBootImagesItemProvisionTemplates)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBootImageProvisionTemplates_EncodeDecode(t *testing.T) {
	var typ BootImageProvisionTemplates
	typ = make(BootImageProvisionTemplates)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BootImageProvisionTemplates
	typ2 = make(BootImageProvisionTemplates)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDataDump_EncodeDecode(t *testing.T) {
	var typ DataDump
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DataDump
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDataDumpHostsItem_EncodeDecode(t *testing.T) {
	var typ DataDumpHostsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DataDumpHostsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDataDumpHostsItemBondsItem_EncodeDecode(t *testing.T) {
	var typ DataDumpHostsItemBondsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DataDumpHostsItemBondsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDataDumpHostsItemInterfacesItem_EncodeDecode(t *testing.T) {
	var typ DataDumpHostsItemInterfacesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DataDumpHostsItemInterfacesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDataDumpImagesItem_EncodeDecode(t *testing.T) {
	var typ DataDumpImagesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DataDumpImagesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDataDumpImagesItemProvisionTemplates_EncodeDecode(t *testing.T) {
	var typ DataDumpImagesItemProvisionTemplates
	typ = make(DataDumpImagesItemProvisionTemplates)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DataDumpImagesItemProvisionTemplates
	typ2 = make(DataDumpImagesItemProvisionTemplates)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDataDumpUsersItem_EncodeDecode(t *testing.T) {
	var typ DataDumpUsersItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DataDumpUsersItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEvent_EncodeDecode(t *testing.T) {
	var typ Event
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Event
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEventJobMessagesItem_EncodeDecode(t *testing.T) {
	var typ EventJobMessagesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EventJobMessagesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEventJobMessagesItemRedfishError_EncodeDecode(t *testing.T) {
	var typ EventJobMessagesItemRedfishError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EventJobMessagesItemRedfishError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEventJobMessagesItemRedfishErrorError_EncodeDecode(t *testing.T) {
	var typ EventJobMessagesItemRedfishErrorError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EventJobMessagesItemRedfishErrorError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEventJobMessagesItemRedfishErrorErrorMessageDotExtendedInfoItem_EncodeDecode(t *testing.T) {
	var typ EventJobMessagesItemRedfishErrorErrorMessageDotExtendedInfoItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EventJobMessagesItemRedfishErrorErrorMessageDotExtendedInfoItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGenericResponse_EncodeDecode(t *testing.T) {
	var typ GenericResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GenericResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHTTPError_EncodeDecode(t *testing.T) {
	var typ HTTPError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HTTPError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHTTPErrorErrorsItem_EncodeDecode(t *testing.T) {
	var typ HTTPErrorErrorsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HTTPErrorErrorsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHTTPErrorErrorsItemMore_EncodeDecode(t *testing.T) {
	var typ HTTPErrorErrorsItemMore
	typ = make(HTTPErrorErrorsItemMore)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HTTPErrorErrorsItemMore
	typ2 = make(HTTPErrorErrorsItemMore)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHost_EncodeDecode(t *testing.T) {
	var typ Host
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Host
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHostBondsItem_EncodeDecode(t *testing.T) {
	var typ HostBondsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HostBondsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHostInterfacesItem_EncodeDecode(t *testing.T) {
	var typ HostInterfacesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HostInterfacesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestJobMessage_EncodeDecode(t *testing.T) {
	var typ JobMessage
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 JobMessage
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestJobMessageRedfishError_EncodeDecode(t *testing.T) {
	var typ JobMessageRedfishError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 JobMessageRedfishError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestJobMessageRedfishErrorError_EncodeDecode(t *testing.T) {
	var typ JobMessageRedfishErrorError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 JobMessageRedfishErrorError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestJobMessageRedfishErrorErrorMessageDotExtendedInfoItem_EncodeDecode(t *testing.T) {
	var typ JobMessageRedfishErrorErrorMessageDotExtendedInfoItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 JobMessageRedfishErrorErrorMessageDotExtendedInfoItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNodeAddRequest_EncodeDecode(t *testing.T) {
	var typ NodeAddRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NodeAddRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNodeAddRequestNodeListItem_EncodeDecode(t *testing.T) {
	var typ NodeAddRequestNodeListItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NodeAddRequestNodeListItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNodeAddRequestNodeListItemBondsItem_EncodeDecode(t *testing.T) {
	var typ NodeAddRequestNodeListItemBondsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NodeAddRequestNodeListItemBondsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNodeAddRequestNodeListItemInterfacesItem_EncodeDecode(t *testing.T) {
	var typ NodeAddRequestNodeListItemInterfacesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NodeAddRequestNodeListItemInterfacesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNodeBootImageRequest_EncodeDecode(t *testing.T) {
	var typ NodeBootImageRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NodeBootImageRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNodeBootTokenResponse_EncodeDecode(t *testing.T) {
	var typ NodeBootTokenResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NodeBootTokenResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNodeBootTokenResponseNodesItem_EncodeDecode(t *testing.T) {
	var typ NodeBootTokenResponseNodesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NodeBootTokenResponseNodesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNodeProvisionRequest_EncodeDecode(t *testing.T) {
	var typ NodeProvisionRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NodeProvisionRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNodeTagsRequest_EncodeDecode(t *testing.T) {
	var typ NodeTagsRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NodeTagsRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRedfishJob_EncodeDecode(t *testing.T) {
	var typ RedfishJob
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RedfishJob
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRedfishJobJobsItem_EncodeDecode(t *testing.T) {
	var typ RedfishJobJobsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RedfishJobJobsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRedfishJobJobsItemMessagesItem_EncodeDecode(t *testing.T) {
	var typ RedfishJobJobsItemMessagesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RedfishJobJobsItemMessagesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRedfishJobJobsItemPayload_EncodeDecode(t *testing.T) {
	var typ RedfishJobJobsItemPayload
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RedfishJobJobsItemPayload
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRedfishJobJobsItemSchedule_EncodeDecode(t *testing.T) {
	var typ RedfishJobJobsItemSchedule
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RedfishJobJobsItemSchedule
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRedfishMetricReport_EncodeDecode(t *testing.T) {
	var typ RedfishMetricReport
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RedfishMetricReport
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRedfishMetricReportReportsItem_EncodeDecode(t *testing.T) {
	var typ RedfishMetricReportReportsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RedfishMetricReportReportsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRedfishMetricReportReportsItemMetricValuesItem_EncodeDecode(t *testing.T) {
	var typ RedfishMetricReportReportsItemMetricValuesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RedfishMetricReportReportsItemMetricValuesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRedfishSystem_EncodeDecode(t *testing.T) {
	var typ RedfishSystem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RedfishSystem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRedfishSystemOem_EncodeDecode(t *testing.T) {
	var typ RedfishSystemOem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RedfishSystemOem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRedfishSystemOemDell_EncodeDecode(t *testing.T) {
	var typ RedfishSystemOemDell
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RedfishSystemOemDell
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRedfishSystemOemDellDellSystem_EncodeDecode(t *testing.T) {
	var typ RedfishSystemOemDellDellSystem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RedfishSystemOemDellDellSystem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUser_EncodeDecode(t *testing.T) {
	var typ User
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 User
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUserRoleRequest_EncodeDecode(t *testing.T) {
	var typ UserRoleRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UserRoleRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUserStoreRequest_EncodeDecode(t *testing.T) {
	var typ UserStoreRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UserStoreRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUserStoreResponse_EncodeDecode(t *testing.T) {
	var typ UserStoreResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UserStoreResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
