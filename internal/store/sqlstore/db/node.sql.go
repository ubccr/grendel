// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: node.sql

package db

import (
	"context"
	"strings"

	null "github.com/guregu/null/v5"
	"github.com/segmentio/ksuid"
)

const nodeAll = `-- name: NodeAll :many
select id, name, uid, host_json from node_view
`

func (q *Queries) NodeAll(ctx context.Context, db DBTX) ([]NodeView, error) {
	rows, err := db.QueryContext(ctx, nodeAll)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NodeView
	for rows.Next() {
		var i NodeView
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.UID,
			&i.Host,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const nodeBootKernel = `-- name: NodeBootKernel :exec
update node set kernel_id = ?1
where id in (/*SLICE:nodes*/?)
`

type NodeBootKernelParams struct {
	KernelID null.Int64 `json:"kernel_id"`
	Nodes    []int64    `json:"nodes"`
}

func (q *Queries) NodeBootKernel(ctx context.Context, db DBTX, arg NodeBootKernelParams) error {
	query := nodeBootKernel
	var queryParams []interface{}
	queryParams = append(queryParams, arg.KernelID)
	if len(arg.Nodes) > 0 {
		for _, v := range arg.Nodes {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:nodes*/?", strings.Repeat(",?", len(arg.Nodes))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:nodes*/?", "NULL", 1)
	}
	_, err := db.ExecContext(ctx, query, queryParams...)
	return err
}

const nodeCount = `-- name: NodeCount :one
/*
 * SPDX-FileCopyrightText: (C) 2019 Grendel Authors
 *
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

select count(*) from node
`

func (q *Queries) NodeCount(ctx context.Context, db DBTX) (int64, error) {
	row := db.QueryRowContext(ctx, nodeCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const nodeDelete = `-- name: NodeDelete :exec
delete from node where name in (/*SLICE:nodeset*/?)
`

func (q *Queries) NodeDelete(ctx context.Context, db DBTX, nodeset []string) error {
	query := nodeDelete
	var queryParams []interface{}
	if len(nodeset) > 0 {
		for _, v := range nodeset {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:nodeset*/?", strings.Repeat(",?", len(nodeset))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:nodeset*/?", "NULL", 1)
	}
	_, err := db.ExecContext(ctx, query, queryParams...)
	return err
}

const nodeFetchByID = `-- name: NodeFetchByID :one
select id, name, uid, host_json from node_view where id = ?1
`

func (q *Queries) NodeFetchByID(ctx context.Context, db DBTX, id int64) (NodeView, error) {
	row := db.QueryRowContext(ctx, nodeFetchByID, id)
	var i NodeView
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.UID,
		&i.Host,
	)
	return i, err
}

const nodeFetchByName = `-- name: NodeFetchByName :one
select id, name, uid, host_json from node_view where name = ?1
`

func (q *Queries) NodeFetchByName(ctx context.Context, db DBTX, name string) (NodeView, error) {
	row := db.QueryRowContext(ctx, nodeFetchByName, name)
	var i NodeView
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.UID,
		&i.Host,
	)
	return i, err
}

const nodeFetchByUID = `-- name: NodeFetchByUID :one
select id, name, uid, host_json from node_view where uid = ?1
`

func (q *Queries) NodeFetchByUID(ctx context.Context, db DBTX, uid string) (NodeView, error) {
	row := db.QueryRowContext(ctx, nodeFetchByUID, uid)
	var i NodeView
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.UID,
		&i.Host,
	)
	return i, err
}

const nodeFind = `-- name: NodeFind :one
select n.id, n.name, n.uid, n.host_json 
from node_view as n
join nic as nc
on nc.node_id = n.id
where 
  case 
    when cast(?1 as integer) then nc.mac = ?2
    when cast(?3 as integer) then nc.ip = ?4
    else 0
  end
limit 1
`

type NodeFindParams struct {
	FilterMAC int64       `json:"filter_mac"`
	MAC       null.String `json:"mac"`
	FilterIP  int64       `json:"filter_ip"`
	IP        null.String `json:"ip"`
}

func (q *Queries) NodeFind(ctx context.Context, db DBTX, arg NodeFindParams) (NodeView, error) {
	row := db.QueryRowContext(ctx, nodeFind,
		arg.FilterMAC,
		arg.MAC,
		arg.FilterIP,
		arg.IP,
	)
	var i NodeView
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.UID,
		&i.Host,
	)
	return i, err
}

const nodeFindNodeset = `-- name: NodeFindNodeset :many
select id, name, uid, host_json from node_view 
where name in (/*SLICE:nodeset*/?)
`

func (q *Queries) NodeFindNodeset(ctx context.Context, db DBTX, nodeset []string) ([]NodeView, error) {
	query := nodeFindNodeset
	var queryParams []interface{}
	if len(nodeset) > 0 {
		for _, v := range nodeset {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:nodeset*/?", strings.Repeat(",?", len(nodeset))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:nodeset*/?", "NULL", 1)
	}
	rows, err := db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NodeView
	for rows.Next() {
		var i NodeView
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.UID,
			&i.Host,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const nodeFindTags = `-- name: NodeFindTags :many
select 
  n.name as name,
  count(distinct(t.key)) as cnt
from
  node as n
join node_tag as nt
  on nt.node_id = n.id 
join tag as t
  on nt.tag_id = t.id 
where 
  t.key in (/*SLICE:tags*/?)
group by name
`

type NodeFindTagsRow struct {
	Name string `json:"name"`
	Cnt  int64  `json:"cnt"`
}

func (q *Queries) NodeFindTags(ctx context.Context, db DBTX, tags []string) ([]NodeFindTagsRow, error) {
	query := nodeFindTags
	var queryParams []interface{}
	if len(tags) > 0 {
		for _, v := range tags {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:tags*/?", strings.Repeat(",?", len(tags))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:tags*/?", "NULL", 1)
	}
	rows, err := db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NodeFindTagsRow
	for rows.Next() {
		var i NodeFindTagsRow
		if err := rows.Scan(&i.Name, &i.Cnt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const nodeID = `-- name: NodeID :many
select id from node
where name in (/*SLICE:nodeset*/?)
`

func (q *Queries) NodeID(ctx context.Context, db DBTX, nodeset []string) ([]int64, error) {
	query := nodeID
	var queryParams []interface{}
	if len(nodeset) > 0 {
		for _, v := range nodeset {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:nodeset*/?", strings.Repeat(",?", len(nodeset))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:nodeset*/?", "NULL", 1)
	}
	rows, err := db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const nodeProvision = `-- name: NodeProvision :exec
update node set provision = ?1
where id in (/*SLICE:nodes*/?)
`

type NodeProvisionParams struct {
	Provision bool    `json:"provision"`
	Nodes     []int64 `json:"nodes"`
}

func (q *Queries) NodeProvision(ctx context.Context, db DBTX, arg NodeProvisionParams) error {
	query := nodeProvision
	var queryParams []interface{}
	queryParams = append(queryParams, arg.Provision)
	if len(arg.Nodes) > 0 {
		for _, v := range arg.Nodes {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:nodes*/?", strings.Repeat(",?", len(arg.Nodes))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:nodes*/?", "NULL", 1)
	}
	_, err := db.ExecContext(ctx, query, queryParams...)
	return err
}

const nodeResolve = `-- name: NodeResolve :many
select nc.fqdn, nc.ip 
from nic as nc
where 
  case 
    when cast(?1 as integer) then lower(nc.fqdn) like concat('%', cast(?2 as text), '%')
    when cast(?3 as integer) then nc.ip like concat(cast(?4 as text), '%')
    else 0
  end
`

type NodeResolveParams struct {
	FilterFQDN int64  `json:"filter_fqdn"`
	FQDN       string `json:"fqdn"`
	FilterIP   int64  `json:"filter_ip"`
	IP         string `json:"ip"`
}

type NodeResolveRow struct {
	FQDN null.String `json:"fqdn"`
	IP   null.String `json:"ip"`
}

func (q *Queries) NodeResolve(ctx context.Context, db DBTX, arg NodeResolveParams) ([]NodeResolveRow, error) {
	rows, err := db.QueryContext(ctx, nodeResolve,
		arg.FilterFQDN,
		arg.FQDN,
		arg.FilterIP,
		arg.IP,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NodeResolveRow
	for rows.Next() {
		var i NodeResolveRow
		if err := rows.Scan(&i.FQDN, &i.IP); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const nodeTagDelete = `-- name: NodeTagDelete :exec
delete from node_tag where node_id in (/*SLICE:nodes*/?) and tag_id in (/*SLICE:tags*/?)
`

type NodeTagDeleteParams struct {
	Nodes []int64 `json:"nodes"`
	Tags  []int64 `json:"tags"`
}

func (q *Queries) NodeTagDelete(ctx context.Context, db DBTX, arg NodeTagDeleteParams) error {
	query := nodeTagDelete
	var queryParams []interface{}
	if len(arg.Nodes) > 0 {
		for _, v := range arg.Nodes {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:nodes*/?", strings.Repeat(",?", len(arg.Nodes))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:nodes*/?", "NULL", 1)
	}
	if len(arg.Tags) > 0 {
		for _, v := range arg.Tags {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:tags*/?", strings.Repeat(",?", len(arg.Tags))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:tags*/?", "NULL", 1)
	}
	_, err := db.ExecContext(ctx, query, queryParams...)
	return err
}

const nodeTagUpsert = `-- name: NodeTagUpsert :exec
insert into node_tag (tag_id, node_id, value)
values (?1, ?2, ?3)
on conflict (tag_id, node_id, value)
do nothing
`

type NodeTagUpsertParams struct {
	TagID  int64  `json:"tag_id"`
	NodeID int64  `json:"node_id"`
	Value  string `json:"value"`
}

func (q *Queries) NodeTagUpsert(ctx context.Context, db DBTX, arg NodeTagUpsertParams) error {
	_, err := db.ExecContext(ctx, nodeTagUpsert, arg.TagID, arg.NodeID, arg.Value)
	return err
}

const nodeTagUpsertDelete = `-- name: NodeTagUpsertDelete :exec
delete from node_tag where node_id in (/*SLICE:nodes*/?) and tag_id not in (/*SLICE:tags*/?)
`

type NodeTagUpsertDeleteParams struct {
	Nodes []int64 `json:"nodes"`
	Tags  []int64 `json:"tags"`
}

func (q *Queries) NodeTagUpsertDelete(ctx context.Context, db DBTX, arg NodeTagUpsertDeleteParams) error {
	query := nodeTagUpsertDelete
	var queryParams []interface{}
	if len(arg.Nodes) > 0 {
		for _, v := range arg.Nodes {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:nodes*/?", strings.Repeat(",?", len(arg.Nodes))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:nodes*/?", "NULL", 1)
	}
	if len(arg.Tags) > 0 {
		for _, v := range arg.Tags {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:tags*/?", strings.Repeat(",?", len(arg.Tags))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:tags*/?", "NULL", 1)
	}
	_, err := db.ExecContext(ctx, query, queryParams...)
	return err
}

const nodeUpsert = `-- name: NodeUpsert :one
insert into node (id, uid, name, provision, arch_id, kernel_id, node_type_id, firmware)
values (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8)
on conflict (name)
do update set provision = ?4, arch_id = ?5, kernel_id = ?6, node_type_id = ?7, firmware = ?8
returning id, uid, name, provision, arch_id, kernel_id, node_type_id, firmware, created_at, updated_at
`

type NodeUpsertParams struct {
	ID         null.Int64  `json:"id"`
	UID        ksuid.KSUID `json:"uid"`
	Name       string      `json:"name"`
	Provision  bool        `json:"provision"`
	ArchID     null.Int64  `json:"arch_id"`
	KernelID   null.Int64  `json:"kernel_id"`
	NodeTypeID null.Int64  `json:"node_type_id"`
	Firmware   null.String `json:"firmware"`
}

func (q *Queries) NodeUpsert(ctx context.Context, db DBTX, arg NodeUpsertParams) (Node, error) {
	row := db.QueryRowContext(ctx, nodeUpsert,
		arg.ID,
		arg.UID,
		arg.Name,
		arg.Provision,
		arg.ArchID,
		arg.KernelID,
		arg.NodeTypeID,
		arg.Firmware,
	)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.UID,
		&i.Name,
		&i.Provision,
		&i.ArchID,
		&i.KernelID,
		&i.NodeTypeID,
		&i.Firmware,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const tagID = `-- name: TagID :many
select id from tag
where key in (/*SLICE:tags*/?)
`

func (q *Queries) TagID(ctx context.Context, db DBTX, tags []string) ([]int64, error) {
	query := tagID
	var queryParams []interface{}
	if len(tags) > 0 {
		for _, v := range tags {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:tags*/?", strings.Repeat(",?", len(tags))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:tags*/?", "NULL", 1)
	}
	rows, err := db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tagUpsert = `-- name: TagUpsert :one
insert into tag (key)
values (?1)
on conflict (key)
do update set key = ?1
returning id, "key"
`

func (q *Queries) TagUpsert(ctx context.Context, db DBTX, key string) (Tag, error) {
	row := db.QueryRowContext(ctx, tagUpsert, key)
	var i Tag
	err := row.Scan(&i.ID, &i.Key)
	return i, err
}
